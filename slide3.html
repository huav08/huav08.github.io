<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Flow Style Carousel</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* 簡單的 UI 導航 */
        .nav {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        .nav button {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.5);
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .nav button:hover { background: white; color: black; }
        
        .title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 4rem;
            pointer-events: none;
            mix-blend-mode: overlay;
            font-weight: bold;
            opacity: 0; /* 預設隱藏，可配合動畫顯示 */
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div class="nav">
        <button id="prevBtn">PREV</button>
        <button id="nextBtn">NEXT</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
        // 圖片資源設定
        const images = [
            'https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?ixlib=rb-1.2.1&auto=format&fit=crop&w=1920&q=80',
            'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?ixlib=rb-1.2.1&auto=format&fit=crop&w=1920&q=80',
            'https://images.unsplash.com/photo-1501854140884-074bf6b24363?ixlib=rb-1.2.1&auto=format&fit=crop&w=1920&q=80',
            'https://images.unsplash.com/photo-1518173946687-a4c8892bbd9f?ixlib=rb-1.2.1&auto=format&fit=crop&w=1920&q=80'
        ];

        // --- 1. 初始化場景 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- 2. 建立自定義幾何體 (將 Plane 拆解為獨立三角形) ---
        function createExplosionGeometry(width, height, segmentsW, segmentsH) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const uvs = [];
            const centers = []; // 每個三角形的中心點，用於計算擴散方向
            const randoms = []; // 隨機值，讓每個碎片運動速度不同

            const widthHalf = width / 2;
            const heightHalf = height / 2;
            const segmentWidth = width / segmentsW;
            const segmentHeight = height / segmentsH;

            // 輔助函數：將一個三角形的資料推入陣列
            function addTriangle(x1, y1, x2, y2, x3, y3, uv1x, uv1y, uv2x, uv2y, uv3x, uv3y) {
                vertices.push(x1, y1, 0, x2, y2, 0, x3, y3, 0);
                uvs.push(uv1x, uv1y, uv2x, uv2y, uv3x, uv3y);
                
                // 計算三角形中心點 (Centroid)
                const cx = (x1 + x2 + x3) / 3;
                const cy = (y1 + y2 + y3) / 3;
                
                // 每個頂點都需要存入相同的中心點資料，這樣它們才會一起移動
                centers.push(cx, cy, 0, cx, cy, 0, cx, cy, 0);

                // 隨機參數 (x: 移動速度, y: 旋轉速度, z: 延遲)
                const r1 = Math.random();
                const r2 = Math.random();
                const r3 = Math.random();
                randoms.push(r1, r2, r3, r1, r2, r3, r1, r2, r3);
            }

            for (let i = 0; i < segmentsW; i++) {
                for (let j = 0; j < segmentsH; j++) {
                    const x = (i * segmentWidth) - widthHalf;
                    const y = (j * segmentHeight) - heightHalf;
                    
                    // UV 座標 (0~1)
                    const u = i / segmentsW;
                    const v = j / segmentsH;
                    const uNext = (i + 1) / segmentsW;
                    const vNext = (j + 1) / segmentsH;

                    // 每個方格切成兩個三角形
                    // 三角形 1
                    addTriangle(
                        x, y,                   // 左下
                        x + segmentWidth, y,    // 右下
                        x, y + segmentHeight,   // 左上
                        u, v,
                        uNext, v,
                        u, vNext
                    );
                    
                    // 三角形 2
                    addTriangle(
                        x + segmentWidth, y,                // 右下
                        x + segmentWidth, y + segmentHeight,// 右上
                        x, y + segmentHeight,               // 左上
                        uNext, v,
                        uNext, vNext,
                        u, vNext
                    );
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setAttribute('aCenter', new THREE.Float32BufferAttribute(centers, 3));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 3));

            return geometry;
        }

        // --- 3. Shader 材質設定 ---
        const vertexShader = `
            uniform float uProgress;
            uniform float uTime;
            
            attribute vec3 aCenter;
            attribute vec3 aRandom;
            
            varying vec2 vUv;

            // 旋轉矩陣函數
            mat4 rotationMatrix(vec3 axis, float angle) {
                axis = normalize(axis);
                float s = sin(angle);
                float c = cos(angle);
                float oc = 1.0 - c;
                return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                            oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                            oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                            0.0,                                0.0,                                0.0,                                1.0);
            }

            void main() {
                vUv = uv;
                
                // 計算進度：0 = 完整, 1 = 破碎
                float prog = uProgress;
                
                // 1. 取得相對於中心的原始位置
                vec3 pos = position - aCenter; 
                
                // 2. 加上隨機旋轉
                // 根據進度和隨機值旋轉
                float rotAngle = prog * aRandom.y * 10.0; 
                mat4 rotMat = rotationMatrix(vec3(aRandom.x, aRandom.y, 1.0), rotAngle);
                pos = (rotMat * vec4(pos, 1.0)).xyz;
                
                // 3. 加上擴散移動
                // 方向：從幾何體中心向外，加上一些 Z 軸變化
                vec3 dir = normalize(aCenter); 
                dir.z += aRandom.z * 2.0; // 增加一些 Z 軸隨機性
                
                // 移動距離：根據進度
                pos += aCenter + dir * prog * 30.0 * aRandom.x; 

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D uTexture;
            varying vec2 vUv;

            void main() {
                vec4 color = texture2D(uTexture, vUv);
                gl_FragColor = color;
            }
        `;

        // --- 4. 建立輪播邏輯 ---
        let currentIndex = 0;
        let isAnimating = false;
        
        // 載入紋理
        const textureLoader = new THREE.TextureLoader();
        const textures = images.map(url => textureLoader.load(url));

        // 建立兩個 Mesh 來做轉場 (Current 和 Next)
        // 幾何體參數：寬, 高, 切割數X, 切割數Y (切割數越高，碎片越多)
        // 注意：為了適應不同螢幕，這裡寬高設為固定比例，實際顯示靠相機距離調整
        const geometry = createExplosionGeometry(40, 25, 30, 20); 

        const material1 = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uProgress: { value: 0 },
                uTexture: { value: textures[0] }
            },
            side: THREE.DoubleSide,
            transparent: true
        });

        const material2 = material1.clone();
        material2.uniforms.uTexture.value = textures[1];
        material2.uniforms.uProgress.value = 1; // 初始狀態設為破碎

        const mesh1 = new THREE.Mesh(geometry, material1);
        const mesh2 = new THREE.Mesh(geometry, material2);
        
        // 為了達到 "Next 從後面飛進來" 的效果，我們將 mesh2 放在稍後的位置
        mesh2.position.z = -10;

        scene.add(mesh1);
        scene.add(mesh2);

        // 用於追蹤當前顯示的是哪一個 mesh
        let activeMesh = mesh1;
        let nextMesh = mesh2;

        // --- 5. 動畫轉場函數 ---
        function goToSlide(index) {
            if (isAnimating) return;
            isAnimating = true;

            const nextIndex = (index + images.length) % images.length;
            
            // 設定下一個 Mesh 的紋理
            nextMesh.material.uniforms.uTexture.value = textures[nextIndex];
            
            // 重置下一個 Mesh 的狀態 (準備進場)
            // 進場策略：從破碎 (progress 1) 到 完整 (progress 0)
            nextMesh.material.uniforms.uProgress.value = 1;
            nextMesh.position.z = -5; // 從稍遠處進場
            nextMesh.visible = true;

            // 當前 Mesh 出場動畫 (破碎並飛散)
            gsap.to(activeMesh.material.uniforms.uProgress, {
                value: 1,
                duration: 1.5,
                ease: "power2.inOut"
            });
            
            gsap.to(activeMesh.position, {
                z: 10, // 向前飛出相機
                duration: 1.5,
                ease: "power2.inOut"
            });

            // 下一個 Mesh 進場動畫 (重組)
            gsap.to(nextMesh.material.uniforms.uProgress, {
                value: 0,
                duration: 1.5,
                ease: "power2.inOut"
            });

            gsap.to(nextMesh.position, {
                z: 0,
                duration: 1.5,
                ease: "power2.inOut",
                onComplete: () => {
                    isAnimating = false;
                    activeMesh.visible = false; // 隱藏舊的
                    
                    // 交換角色
                    const temp = activeMesh;
                    activeMesh = nextMesh;
                    nextMesh = temp;
                    
                    currentIndex = nextIndex;
                }
            });
        }

        // --- 6. 事件監聽 ---
        document.getElementById('nextBtn').addEventListener('click', () => {
            goToSlide(currentIndex + 1);
        });

        document.getElementById('prevBtn').addEventListener('click', () => {
            goToSlide(currentIndex - 1);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 7. Render Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            // 讓碎片有點浮動感 (可選)
            if (activeMesh.material.uniforms.uProgress.value > 0) {
                 // 這裡可以加入持續的噪聲波動
            }

            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>